import numpy as np
# ------------------- TO BE CHANGED LATER
# - make worlds 101 x 101
# - stop loop also if openList is empty
# - assume blocks

# states implemented as Nodes
# 'x' and 'y' are ints indicating state's location
# 'g','heuristic', and 'f' are self-explanatory
# 'direction' is the state's parent
class Node:
    def __init__(self, x, y, g, heuristic, f, direction):
        self.x = x
        self.y = y
        self.g = g
        self.heuristic = heuristic
        self.f = f
        self.direction = direction



# executes the path
def main():

    # real world where 1's are blocks
    true_matrix = np.array([[0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0]])

    # mentalMatrix is initialized to be all 0's
    mentalMatrix = np.array([[0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0],
                            [0, 0, 0, 0, 0]])

    # initializes start state in top left corner
    start = Node (0,0,0,8,8,None)

    # initializes goal state in bottom right corner
    goal = Node (4,4,None,0,None,None)

    # 2 indicates start, 3 indicates goal
    mentalMatrix[start.x][start.y] = 2
    mentalMatrix[goal.x][goal.y] = 3
    print(mentalMatrix)
    # loop will run until it reaches goal, or share same location
    while start.x != goal.x and start.y != goal.y:

        # node = the goal node
        node = computePath(start,goal,mentalMatrix)

        # increases visibility of mentalMatrix only if in bounds
        if start.x + 1 <= 4 and start.y + 1 <= 4:
            mentalMatrix[start.x + 1][start.y + 1] = true_matrix[start.x + 1][start.y + 1]
        if start.x + 1 <= 4 and start.y - 1 >= 0:
            mentalMatrix[start.x + 1][start.y - 1] = true_matrix[start.x + 1][start.y - 1]
        if start.x - 1 >= 0 and start.y + 1 <= 4:
            mentalMatrix[start.x - 1][start.y + 1] = true_matrix[start.x - 1][start.y + 1]
        if start.x - 1 >= 0 and start.y - 1 >= 0:
            mentalMatrix[start.x - 1][start.y - 1] = true_matrix[start.x - 1][start.y - 1]

        # stop when 'nodePrev' equals the node before 'start'
        while nodeCurr.x != goal.x and nodeCurr.y != goal.y :

            # 2 node ptrs, one points behind the other
            nodeCurr = node
            nodePrev = None
            nodePrev.direction = nodeCurr

            # loop until 'nodeCurr' = start coordinates
            while nodeCurr.x != start.x and nodeCurr.y != start.y:
                nodePrev = nodeCurr
                nodeCurr = nodeCurr.direction

            # change 'start' locations
            start.x = nodePrev.x
            start.y = nodePrev.y

            # update mentalMatrix path to show whats been traversed
            mentalMatrix[start.x][start.y] = 'x'

            # increases visibility of mentalMatrix only if in bounds
            if start.x + 1 <= 4 and start.y + 1 <= 4:
                mentalMatrix[start.x + 1][start.y + 1] = true_matrix[start.x + 1][start.y + 1]
            if start.x + 1 <= 4 and start.y - 1 >= 0:
                mentalMatrix[start.x + 1][start.y - 1] = true_matrix[start.x + 1][start.y - 1]
            if start.x - 1 >= 0 and start.y + 1 <= 4:
                mentalMatrix[start.x - 1][start.y + 1] = true_matrix[start.x - 1][start.y + 1]
            if start.x - 1 >= 0 and start.y - 1 >= 0:
                mentalMatrix[start.x - 1][start.y - 1] = true_matrix[start.x - 1][start.y - 1]


main()
