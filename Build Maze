# ----- SHORTCUTS
# shift + tab = dedent
# 2 matrices: 1 of nodes, 1 of ints (0, 1)
# node class has (integer, visited, N, E, S, W?)
# ? DFS
# ! go to another node (jumps by 2 indeces) set the 1 index in between to 0 and corresponding to int matrix
# print int matrix, import num py
import random
import numpy as num
from numpy import zeros

# x = size of gridworld
x = 7
gridworld = zeros([x, x])

# creates tic-tac-toe pattern of walls, to be broken down
for row in range(1, x, 2):
    for col in range(x):
        gridworld[row][col] = 1
for col in range(1, x, 2):
    for row in range(x):
        gridworld[row][col] = 1

# confirms tic-tac-toe pattern
print(gridworld)

# for marking as visited
class Node:
    def __init__(self, data,next):
        self.data = data
        self.next = next

# creates
num_rows = x
num_cols = x
row = [Node(1,None)]*num_rows
# The original way doesn't behave exactly right, this avoids
# deep nesting of the array. Also adding list(row) to create
# a new object rather than carrying references to row to all rows
nodeMatrix = [list(row) for i in range(num_cols)]


class Queue:
    def __init__(self):
        self.items = []

    def isEmpty(self):
        return self.items == []

    def enqueue(self, item):
        self.items.insert(0,item)

    def dequeue(self):
        return self.items.pop()

    def size(self):
        return len(self.items)



